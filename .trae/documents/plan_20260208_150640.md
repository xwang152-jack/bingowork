I will implement the backend logic for "Delete" and "Regenerate" messages, and then connect it to the frontend.

### 1. Backend Implementation
*   **`electron/agent/AgentConstants.ts`**: Define `AgentMessage` type (extending `Anthropic.MessageParam` with `id`) to ensure consistent types across the system.
*   **`electron/agent/state/AgentStateManager.ts`**:
    *   Update history storage to use `AgentMessage[]`.
    *   Update `addToHistory` to auto-generate UUIDs for messages if missing.
    *   Implement `deleteMessage(id: string)`: Removes a specific message.
    *   Implement `truncateHistory(id: string)`: Removes a message and all subsequent messages, returning the removed items (needed for regeneration logic).
*   **`electron/agent/AgentRuntime.ts`**:
    *   Implement `deleteMessage(id: string)`: Calls state manager and notifies UI.
    *   Implement `regenerate(id: string)`:
        *   Truncates history from the given message ID.
        *   If the target was an AI message, simply calls `runLoop()` (re-inference).
        *   If the target was a User message, re-submits the user content via `processUserMessage()`.

### 2. IPC Layer
*   **`electron/constants/IpcChannels.ts`**: Add `DELETE_MESSAGE` (`agent:delete-message`) and `REGENERATE` (`agent:regenerate`) channels.
*   **`electron/ipc/handlers/agentHandlers.ts`**: Register handlers for these new channels and delegate to `AgentRuntime`.

### 3. Frontend Implementation
*   **`electron/services/IPCService.ts`**: Add `deleteMessage` and `regenerateMessage` methods calling `ipcRenderer`.
*   **`src/hooks/useAgent.ts`**: Expose `deleteMessage` and `regenerateMessage` in the hook.
*   **`src/components/cowork/MessageList.tsx`**:
    *   Accept `onDelete` and `onRegenerate` props.
    *   Wire up the "Delete" and "Retry" (Regenerate) buttons in `MessageItem`.
*   **`src/components/MainInterface.tsx`**: Pass the new handlers from `useAgent` to `MessageList`.

I will start by updating the backend types and state management.